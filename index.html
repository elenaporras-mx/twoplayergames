<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GAME HUB v1.0 - [CLASSIFIED ACCESS]</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

* { 
  margin: 0; 
  padding: 0; 
  box-sizing: border-box; 
}

body {
  font-family: 'Orbitron', 'Courier New', monospace;
  background: #000;
  background-image: 
    radial-gradient(circle at 25% 25%, #001122 0%, transparent 50%),
    radial-gradient(circle at 75% 75%, #110022 0%, transparent 50%),
    linear-gradient(45deg, #000011 0%, #000022 25%, #001100 50%, #002200 75%, #000011 100%);
  min-height: 100vh;
  color: #00ff00;
  text-shadow: 0 0 10px #00ff00;
  animation: scanlines 0.1s linear infinite;
  overflow-x: hidden;
}

@keyframes scanlines {
  0% { background-position: 0 0; }
  100% { background-position: 0 2px; }
}

body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 255, 0, 0.03) 2px,
    rgba(0, 255, 0, 0.03) 4px
  );
  pointer-events: none;
  z-index: 1000;
}

/* LOGIN SCREEN */
.login-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #001100;
  border: 4px solid #00ff00;
  border-radius: 0;
  padding: 40px;
  box-shadow: 
    0 0 20px #00ff00,
    inset 0 0 20px rgba(0, 255, 0, 0.1);
  text-align: center;
  max-width: 500px;
  width: 90%;
  animation: flicker 2s infinite alternate;
}

@keyframes flicker {
  0%, 98% { opacity: 1; }
  99% { opacity: 0.95; }
  100% { opacity: 1; }
}

.login-container h2 {
  color: #00ffff;
  font-size: 1.8em;
  margin-bottom: 20px;
  text-transform: uppercase;
  letter-spacing: 3px;
  text-shadow: 0 0 15px #00ffff;
}

.login-input, .login-button {
  width: 100%;
  padding: 15px;
  margin-bottom: 15px;
  border: 2px solid #00ff00;
  background: #000;
  color: #00ff00;
  font-family: 'Orbitron', monospace;
  font-size: 1.1em;
  text-align: center;
}

.login-input {
  background: rgba(0, 255, 0, 0.1);
}

.login-input:focus {
  outline: none;
  box-shadow: 0 0 10px #00ff00;
  background: rgba(0, 255, 0, 0.2);
}

.login-button {
  background: #003300;
  cursor: pointer;
  font-weight: bold;
  transition: all 0.2s;
  text-shadow: 0 0 5px #00ff00;
  text-transform: uppercase;
}

.login-button:hover {
  background: #00ff00;
  color: #000;
  box-shadow: 0 0 20px #00ff00;
  text-shadow: none;
}

.error-message {
  color: #ff0000;
  font-weight: bold;
  text-shadow: 0 0 10px #ff0000;
  animation: errorBlink 0.5s infinite;
}

@keyframes errorBlink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.3; }
}

.game-container {
  display: none;
  width: 100%;
  padding: 20px;
}

/* HEADER */
.header {
  text-align: center;
  margin-bottom: 30px;
  background: rgba(0, 17, 0, 0.8);
  border: 4px solid #00ff00;
  padding: 20px 40px;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
  position: relative;
}

.header::before {
  content: ">>> SECURE CONNECTION ESTABLISHED <<<";
  position: absolute;
  top: -15px;
  left: 50%;
  transform: translateX(-50%);
  background: #000;
  padding: 0 10px;
  font-size: 0.8em;
  color: #00ffff;
  text-shadow: 0 0 5px #00ffff;
}

.header h1 {
  color: #00ffff;
  font-size: 3em;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 5px;
  text-shadow: 0 0 20px #00ffff;
  margin-bottom: 20px;
}

.players-setup {
  display: flex;
  gap: 30px;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.player-input {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.player-input label {
  color: #ffff00;
  font-weight: bold;
  text-transform: uppercase;
  text-shadow: 0 0 5px #ffff00;
}

.player-input input {
  padding: 10px;
  border: 2px solid #00ff00;
  background: rgba(0, 255, 0, 0.1);
  color: #00ff00;
  text-align: center;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-transform: uppercase;
}

.global-score {
  display: flex;
  gap: 30px;
  justify-content: center;
  font-weight: 700;
  flex-wrap: wrap;
  align-items: center;
}

.score-item {
  background: rgba(255, 255, 0, 0.1);
  border: 2px solid #ffff00;
  padding: 10px 20px;
  color: #ffff00;
  text-shadow: 0 0 10px #ffff00;
  text-transform: uppercase;
}

/* PROFILE PICTURES */
.profile-section {
  display: flex;
  align-items: center;
  gap: 15px;
}

.profile-picture {
  width: 50px;
  height: 50px;
  border: 2px solid #00ff00;
  border-radius: 50%;
  object-fit: cover;
  cursor: pointer;
  transition: all 0.3s;
  background: rgba(0, 255, 0, 0.1);
}

.profile-picture:hover {
  border-color: #00ffff;
  box-shadow: 0 0 15px #00ffff;
  transform: scale(1.1);
}

.profile-picture.placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5em;
  color: #00ff00;
  text-shadow: 0 0 10px #00ff00;
}

.upload-button {
  background: #003300;
  color: #00ff00;
  border: 1px solid #00ff00;
  padding: 5px 10px;
  font-family: 'Orbitron', monospace;
  font-size: 0.8em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.2s;
}

.upload-button:hover {
  background: #00ff00;
  color: #000;
  box-shadow: 0 0 10px #00ff00;
}

.file-input {
  display: none;
}

/* Secret reset styles */
.secret-reset {
  position: fixed;
  bottom: 10px;
  right: 10px;
  width: 20px;
  height: 20px;
  background: transparent;
  border: none;
  cursor: pointer;
  opacity: 0;
}

/* GAMES GRID */
.games-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 25px;
  max-width: 1400px;
  margin: 0 auto 30px;
}

.game-card {
  background: rgba(0, 17, 0, 0.9);
  border: 3px solid #00ff00;
  padding: 25px;
  text-align: center;
  box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.game-card::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(45deg, transparent, rgba(0, 255, 0, 0.1), transparent);
  transform: rotate(45deg);
  transition: all 0.5s;
  opacity: 0;
}

.game-card:hover::before {
  opacity: 1;
  animation: sweep 1s linear;
}

@keyframes sweep {
  0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
  100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
}

.game-card:hover {
  transform: scale(1.05);
  border-color: #00ffff;
  box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
}

.game-card h3 {
  color: #00ffff;
  font-size: 1.4em;
  margin-bottom: 15px;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 0 0 10px #00ffff;
}

.play-button {
  background: #003300;
  color: #00ff00;
  border: 2px solid #00ff00;
  padding: 12px 25px;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.2s;
  text-shadow: 0 0 5px #00ff00;
}

.play-button:hover {
  background: #00ff00;
  color: #000;
  box-shadow: 0 0 15px #00ff00;
  text-shadow: none;
}

/* GAME RESULT SCREENS */
.game-result-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10001;
  animation: fadeIn 0.5s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.result-screen {
  background: rgba(0, 17, 0, 0.98);
  border: 4px solid;
  padding: 50px;
  text-align: center;
  max-width: 600px;
  width: 90%;
  box-shadow: 0 0 50px;
  animation: slideIn 0.6s ease-out 0.2s both;
}

@keyframes slideIn {
  from { transform: translateY(-50px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.winner-screen {
  border-color: #00ff00;
  box-shadow: 0 0 50px #00ff00;
}

.loser-screen {
  border-color: #ff0040;
  box-shadow: 0 0 50px #ff0040;
}

.draw-screen {
  border-color: #ffff00;
  box-shadow: 0 0 50px #ffff00;
}

.result-title {
  font-size: 3em;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 5px;
  margin-bottom: 30px;
  text-shadow: 0 0 20px currentColor;
}

.winner-screen .result-title {
  color: #00ff00;
  animation: pulse 2s infinite;
}

.loser-screen .result-title {
  color: #ff0040;
}

.draw-screen .result-title {
  color: #ffff00;
}

.result-message {
  font-size: 1.3em;
  margin-bottom: 30px;
  color: #00ffff;
  text-shadow: 0 0 15px #00ffff;
  line-height: 1.6;
}

.result-stats {
  background: rgba(0, 0, 0, 0.5);
  border: 2px solid #00ff00;
  padding: 20px;
  margin: 20px 0;
  color: #00ff00;
  text-shadow: 0 0 10px #00ff00;
}

.result-buttons {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin-top: 40px;
  flex-wrap: wrap;
}

.result-button {
  background: #003300;
  color: #00ff00;
  border: 2px solid #00ff00;
  padding: 15px 30px;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s;
  text-shadow: 0 0 5px #00ff00;
  font-size: 1.1em;
}

.result-button:hover {
  background: #00ff00;
  color: #000;
  box-shadow: 0 0 20px #00ff00;
  text-shadow: none;
  transform: scale(1.05);
}

.result-button.secondary {
  background: #330000;
  color: #ff0040;
  border-color: #ff0040;
  text-shadow: 0 0 5px #ff0040;
}

.result-button.secondary:hover {
  background: #ff0040;
  color: #000;
  box-shadow: 0 0 20px #ff0040;
}

/* GAME AREA */
.game-area {
  display: none;
  background: rgba(0, 17, 0, 0.95);
  border: 4px solid #00ff00;
  padding: 30px;
  max-width: 900px;
  width: 100%;
  margin: 0 auto 20px;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
}

.game-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 15px;
}

.back-button {
  background: #330000;
  color: #ff0000;
  border: 2px solid #ff0000;
  padding: 10px 15px;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-transform: uppercase;
  cursor: pointer;
  text-shadow: 0 0 5px #ff0000;
}

.back-button:hover {
  background: #ff0000;
  color: #000;
  box-shadow: 0 0 15px #ff0000;
  text-shadow: none;
}

.current-player {
  font-weight: 700;
  color: #ffff00;
  text-shadow: 0 0 10px #ffff00;
  text-transform: uppercase;
}

/* GAME STYLES */
.connect4-board {
  display: grid;
  grid-template-columns: repeat(7, 60px);
  gap: 5px;
  justify-content: center;
  margin: 20px 0;
}

.connect4-cell {
  width: 60px;
  height: 60px;
  border: 3px solid #00ff00;
  background: rgba(0, 255, 0, 0.1);
  cursor: pointer;
  transition: all 0.2s;
}

.connect4-cell:hover {
  background: rgba(0, 255, 0, 0.2);
  box-shadow: 0 0 10px #00ff00;
}

.connect4-cell.red { background: #ff0040; box-shadow: 0 0 10px #ff0040; }
.connect4-cell.yellow { background: #ffff00; box-shadow: 0 0 10px #ffff00; }

.tic-tac-toe-board {
  display: grid;
  grid-template-columns: repeat(3, 100px);
  gap: 5px;
  justify-content: center;
  margin: 20px 0;
}

.tic-tac-toe-cell {
  width: 100px;
  height: 100px;
  background: rgba(0, 255, 0, 0.1);
  border: 3px solid #00ff00;
  font-size: 2.5em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #00ffff;
  text-shadow: 0 0 10px #00ffff;
  transition: all 0.2s;
}

.tic-tac-toe-cell:hover {
  background: rgba(0, 255, 0, 0.2);
  box-shadow: 0 0 15px #00ff00;
}

.number-grid {
  display: grid;
  grid-template-columns: repeat(4, 100px);
  gap: 10px;
  justify-content: center;
  margin: 20px 0;
}

.number-button {
  width: 100px;
  height: 100px;
  background: rgba(0, 255, 0, 0.2);
  border: 2px solid #00ff00;
  color: #00ffff;
  font-size: 1.5em;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s;
  text-shadow: 0 0 10px #00ffff;
}

.number-button:hover, .number-button.selected {
  background: rgba(0, 255, 255, 0.3);
  box-shadow: 0 0 15px #00ffff;
}

/* INPUT STYLES */
.word-input, .anagram-input, .wordchain-input, .math-input, .message-input {
  width: 100%;
  padding: 15px;
  margin-bottom: 15px;
  border: 2px solid #00ff00;
  background: rgba(0, 255, 0, 0.1);
  color: #00ff00;
  font-family: 'Orbitron', monospace;
  font-size: 1.1em;
  text-align: center;
  text-transform: uppercase;
}

.word-input:focus, .anagram-input:focus, .wordchain-input:focus, .math-input:focus, .message-input:focus {
  outline: none;
  background: rgba(0, 255, 0, 0.2);
  box-shadow: 0 0 15px #00ff00;
}

.submit-button, .roll-button, .send-message, .clear-messages {
  background: #003300;
  color: #00ff00;
  border: 2px solid #00ff00;
  padding: 12px 25px;
  font-family: 'Orbitron', monospace;
  font-weight: bold;
  text-transform: uppercase;
  cursor: pointer;
  margin: 5px;
  transition: all 0.2s;
  text-shadow: 0 0 5px #00ff00;
}

.submit-button:hover, .roll-button:hover, .send-message:hover, .clear-messages:hover {
  background: #00ff00;
  color: #000;
  box-shadow: 0 0 15px #00ff00;
  text-shadow: none;
}

/* GAME INFO */
.game-info {
  text-align: center;
  margin-bottom: 20px;
  color: #ffff00;
  font-weight: bold;
  text-shadow: 0 0 10px #ffff00;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.timer {
  text-align: center;
  font-size: 2em;
  color: #ff0040;
  font-weight: bold;
  text-shadow: 0 0 15px #ff0040;
  margin: 15px 0;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

.dice {
  font-size: 4em;
  text-align: center;
  margin: 20px 0;
  text-shadow: 0 0 20px currentColor;
}

/* PANELS */
.history-panel, .messages-panel {
  background: rgba(0, 17, 0, 0.95);
  border: 3px solid #00ff00;
  padding: 20px;
  margin: 20px auto;
  max-width: 900px;
  box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
}

.messages-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
  flex-wrap: wrap;
  gap: 10px;
}

.messages-header h4 {
  color: #00ffff;
  text-transform: uppercase;
  text-shadow: 0 0 10px #00ffff;
}

.messages-container {
  max-height: 200px;
  overflow-y: auto;
  border: 2px solid #00ff00;
  padding: 15px;
  margin-bottom: 15px;
  background: rgba(0, 0, 0, 0.5);
}

.message {
  margin-bottom: 10px;
  padding: 8px;
  border-left: 3px solid #00ff00;
  background: rgba(0, 255, 0, 0.05);
}

.message-sender {
  font-size: 0.8em;
  color: #ffff00;
  text-shadow: 0 0 5px #ffff00;
  margin-bottom: 3px;
  text-transform: uppercase;
}

.message-text {
  color: #00ff00;
  text-shadow: 0 0 5px #00ff00;
}

.message-input-container {
  display: flex;
  gap: 10px;
}

.message-input {
  flex: 1;
  text-align: left;
}

/* DRAWING */
.drawing-canvas {
  border: 3px solid #00ff00;
  background: #000;
  margin: 10px 0;
  cursor: crosshair;
  box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
}

.color-palette {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 15px 0;
}

.color-button {
  width: 30px;
  height: 30px;
  border: 2px solid #00ff00;
  cursor: pointer;
  transition: all 0.2s;
}

.color-button:hover, .color-button.active {
  transform: scale(1.2);
  box-shadow: 0 0 10px #00ff00;
}

/* RESPONSIVE */
@media (max-width: 768px) {
  .header h1 { font-size: 2em; }
  .games-grid { grid-template-columns: 1fr; }
  .game-header { flex-direction: column; text-align: center; }
  .players-setup { flex-direction: column; }
  .global-score { flex-direction: column; gap: 10px; }
}

/* SCROLLBAR */
::-webkit-scrollbar {
  width: 12px;
}

::-webkit-scrollbar-track {
  background: #000;
}

::-webkit-scrollbar-thumb {
  background: #00ff00;
  box-shadow: 0 0 10px #00ff00;
}

::-webkit-scrollbar-thumb:hover {
  background: #00ffff;
}
</style>
</head>
<body>

<!-- LOGIN -->
<div class="login-container" id="loginScreen">
  <h2>[CLASSIFIED ACCESS]</h2>
  <div style="margin-bottom: 20px; color: #ffff00; font-size: 0.9em;">
    ENTER AUTHORIZATION CODE
  </div>
  <input type="password" class="login-input" id="passwordInput" placeholder="PASSWORD">
  <button class="login-button" id="loginButton">INITIALIZE</button>
  <div class="error-message" id="errorMessage"></div>
</div>

<!-- GAME HUB -->
<div class="game-container" id="gameContainer">
  <div class="header">
    <h1>GAME HUB v1.0</h1>
    <div class="players-setup">
      <div class="player-input">
        <label>PLAYER 1:</label>
        <div class="profile-section">
          <div class="profile-picture placeholder" id="profile1" onclick="selectProfilePicture(1)">
            P1
          </div>
          <div>
            <input type="text" id="player1Name" value="ELENA">
            <button class="upload-button" onclick="selectProfilePicture(1)">UPLOAD</button>
          </div>
        </div>
        <input type="file" id="fileInput1" class="file-input" accept="image/*" onchange="handleProfileUpload(1, event)">
      </div>
      <div class="player-input">
        <label>PLAYER 2:</label>
        <div class="profile-section">
          <div class="profile-picture placeholder" id="profile2" onclick="selectProfilePicture(2)">
            P2
          </div>
          <div>
            <input type="text" id="player2Name" value="BRYAN">
            <button class="upload-button" onclick="selectProfilePicture(2)">UPLOAD</button>
          </div>
        </div>
        <input type="file" id="fileInput2" class="file-input" accept="image/*" onchange="handleProfileUpload(2, event)">
      </div>
    </div>
    <div class="global-score">
      <div class="score-item"><span id="player1GlobalScore">ELENA: 0 WINS</span></div>
      <div class="score-item"><span id="player2GlobalScore">BRYAN: 0 WINS</span></div>
      <button class="back-button" onclick="logout()" style="margin-left: 20px;">LOGOUT</button>
    </div>
  </div>

  <div class="games-grid" id="gamesGrid">
    <div class="game-card" onclick="startGame('connect4')">
      <h3>█ CONNECT 4</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('tictactoe')">
      <h3>█ TIC TAC TOE</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('anagrams')">
      <h3>█ ANAGRAMS</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('memory')">
      <h3>█ MEMORY MATCH</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('mathrace')">
      <h3>█ MATH RACE</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('drawguess')">
      <h3>█ DRAW & GUESS</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('dicerace')">
      <h3>█ DICE RACE</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('sequence')">
      <h3>█ SEQUENCE MEMORY</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('wordchain')">
      <h3>█ WORD CHAIN</h3>
      <button class="play-button">EXECUTE</button>
    </div>
    <div class="game-card" onclick="startGame('quickdraw')">
      <h3>█ QUICK DRAW</h3>
      <button class="play-button">EXECUTE</button>
    </div>
  </div>

  <div class="game-area" id="gameArea">
    <div class="game-header">
      <button class="back-button" onclick="backToMenu()">← TERMINATE</button>
      <h2 id="gameTitle"></h2>
      <div style="display: flex; gap: 10px; align-items: center;">
        <button class="back-button" onclick="restartGame()" style="background: #003300; color: #00ff00; border-color: #00ff00;">↻ RESTART</button>
        <div class="current-player" id="currentPlayer"></div>
      </div>
    </div>
    <div id="gameContent"></div>
  </div>

  <div class="history-panel" id="historyPanel">
    <h3 style="color: #00ffff; text-shadow: 0 0 10px #00ffff; text-transform: uppercase; margin-bottom: 15px;">GAME LOGS</h3>
    <div id="historyContent"></div>
  </div>
  
  <div class="messages-panel" id="messagesPanel">
    <div class="messages-header">
      <h4>█ SECURE CHAT</h4>
      <button class="clear-messages" onclick="clearMessages()">CLEAR LOG</button>
    </div>
    <div class="messages-container" id="messagesContainer">
      <div style="text-align:center;color:#666;">AWAITING TRANSMISSION...</div>
    </div>
    <div class="message-input-container">
      <input type="text" class="message-input" id="messageInput" placeholder="ENTER MESSAGE">
      <button class="send-message" onclick="sendMessage()">TRANSMIT</button>
    </div>
  </div>
</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyAbPfydjja8d1Wsfn4O6FciBWb6njE-ckk",
  authDomain: "playergames-18360.firebaseapp.com",
  databaseURL: "https://playergames-18360-default-rtdb.firebaseio.com",
  projectId: "playergames-18360",
  storageBucket: "playergames-18360.firebasestorage.app",
  messagingSenderId: "1091542186566",
  appId: "1:1091542186566:web:6f897cac10a344d4226847"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();


const PLAYER1_PASSWORD = "ESittingInATree";
const PLAYER2_PASSWORD = "BSittingInATree";
let myPlayerNumber = null;
let otherPlayerConnected = false;
  
let isLoggedIn = false;
let activityTimeout;
let lastActivityTime = Date.now();
let gameResultHandled = false;
const TIMEOUT_DURATION = 15 * 60 * 1000;

// Global functions
function saveData() {
  window.gameData = { 
    gameHistory, 
    globalScores, 
    player1Name: document.getElementById('player1Name').value,
    player2Name: document.getElementById('player2Name').value, 
    gameMessages,
    profilePictures  // ADD THIS LINE
  };
  sessionStorage.setItem('gameHubData', JSON.stringify(window.gameData));
}

function loadData() {
  // First try to load from session storage
  const savedData = sessionStorage.getItem('gameHubData');
  if (savedData) {
    try {
      const data = JSON.parse(savedData);
      gameHistory = data.gameHistory || {};
      globalScores = data.globalScores || { player1: 0, player2: 0 };
      gameMessages = data.gameMessages || [];
      if (data.player1Name) document.getElementById('player1Name').value = data.player1Name;
      if (data.player2Name) document.getElementById('player2Name').value = data.player2Name;
      window.gameData = data;
      loadProfilePictures(); 
      return;
    } catch(e) {
      console.error('Error loading saved data:', e);
    }
  }
  
  // Fallback to window.gameData if available
  if (window.gameData) {
    const data = window.gameData;
    gameHistory = data.gameHistory || {};
    globalScores = data.globalScores || { player1: 0, player2: 0 };
    gameMessages = data.gameMessages || [];
    if (data.player1Name) document.getElementById('player1Name').value = data.player1Name;
    if (data.player2Name) document.getElementById('player2Name').value = data.player2Name;
  }
  
  // Load profile pictures regardless of data source
  loadProfilePictures(); 
}

function logout() {
  // Set logged out FIRST to prevent any callbacks from executing
  isLoggedIn = false;
  
  // Clean up Firebase connection
  if (myPlayerNumber) {
    database.ref(`gameSession/player${myPlayerNumber}`).update({
      connected: false,
      lastSeen: firebase.database.ServerValue.TIMESTAMP
    });
  }

  // Remove ALL Firebase listeners
  if (window.firebaseListeners) {
    window.firebaseListeners.forEach(listener => {
      listener.ref.off('value', listener.callback);
      listener.ref.off('child_added', listener.callback);
    });
    window.firebaseListeners = [];
  }
  
  // Remove all listeners from the entire Firebase reference
  database.ref().off();
  
  // Clear heartbeat
  if (window.currentHeartbeat) {
    clearInterval(window.currentHeartbeat);
    window.currentHeartbeat = null;
  }

  // Save data before logout
  saveData();
  
  database.ref('gameSession/gameResult').remove();

  // Clear timeout and reset login state
  clearTimeout(activityTimeout);
  currentGame = null;
  gameState = {};
  myPlayerNumber = null;
  otherPlayerConnected = false;
  
  // Remove connection status div
  const statusDiv = document.getElementById('connectionStatus');
  if (statusDiv) statusDiv.remove();
  
  // Show login screen
  document.getElementById('loginScreen').style.display = 'block';
  document.getElementById('gameContainer').style.display = 'none';
  document.getElementById('passwordInput').value = '';
  
  // Show logout confirmation
  const logoutDiv = document.createElement('div');
  logoutDiv.style.cssText = `position: fixed; top: 20px; right: 20px; background: rgba(0, 51, 0, 0.95);
    border: 2px solid #00ff00; padding: 15px; color: #00ff00; text-shadow: 0 0 10px #00ff00;
    font-family: 'Orbitron', monospace; font-weight: bold; text-transform: uppercase; z-index: 10000;`;
  logoutDiv.textContent = 'LOGOUT SUCCESSFUL - DATA SAVED';
  document.body.appendChild(logoutDiv);
  setTimeout(() => { if (logoutDiv.parentNode) logoutDiv.remove(); }, 3000);
}
window.logout = logout;

function restartGame() {
  if (!currentGame) return;
  
  // Reset game state and reinitialize current game
  currentPlayer = 1;
  gameState = { currentPlayer: 1 }; 
  updatePlayerNames();
  
  const gameConfig = getGameConfig(currentGame);
  document.getElementById('gameContent').innerHTML = gameConfig.html;
  if (gameConfig.init) gameConfig.init();

  syncGameState();
  
  // Show restart confirmation
  const restartDiv = document.createElement('div');
  restartDiv.style.cssText = `position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(0, 51, 0, 0.95); border: 2px solid #00ff00; padding: 10px 20px; 
    color: #00ff00; text-shadow: 0 0 10px #00ff00; font-family: 'Orbitron', monospace; 
    font-weight: bold; text-transform: uppercase; z-index: 10000;`;
  restartDiv.textContent = 'GAME RESTARTED';
  document.body.appendChild(restartDiv);
  setTimeout(() => { if (restartDiv.parentNode) restartDiv.remove(); }, 2000);
}
window.restartGame = restartGame;
  
function checkPassword() {
  const inputPassword = document.getElementById('passwordInput').value;
  
  if(inputPassword === PLAYER1_PASSWORD) {
    myPlayerNumber = 1;
    loginAsPlayer(1);
  } else if(inputPassword === PLAYER2_PASSWORD) {
    myPlayerNumber = 2;
    loginAsPlayer(2);
  } else {
    document.getElementById('errorMessage').textContent='ACCESS DENIED - INVALID CODE';
    document.getElementById('passwordInput').value='';
    return;
  }
}
window.checkPassword = checkPassword;

function loginAsPlayer(playerNum) {
  isLoggedIn = true;
  document.getElementById('loginScreen').style.display='none';
  document.getElementById('gameContainer').style.display='block';
  document.getElementById('errorMessage').textContent = '';
  
  // Connect to Firebase
  connectToFirebase(playerNum);
  loadData();
  updateGlobalScores();
  updatePlayerNames();

  // Set initial location to lobby
  setTimeout(() => {
    updatePlayerLocation('lobby');
    updatePanelVisibility();
    console.log('Initial location set to lobby');
  }, 500);

  try { startActivityMonitor(); } catch(e) { console.error(e); }
}

function connectToFirebase(playerNum) {
  // Store listener references for proper cleanup
  window.firebaseListeners = window.firebaseListeners || [];
  
  const playerRef = database.ref(`gameSession/player${playerNum}`);
  
  // Set up disconnect handling
  playerRef.onDisconnect().update({
    connected: false,
    lastSeen: firebase.database.ServerValue.TIMESTAMP
  });
  
  // Mark this player as connected
  playerRef.set({
    name: document.getElementById(`player${playerNum}Name`).value.toUpperCase(),
    connected: true,
    lastSeen: firebase.database.ServerValue.TIMESTAMP
  });

  // Listen for other player's location
  const otherPlayerNum = playerNum === 1 ? 2 : 1;
  const otherPlayerListener = database.ref(`gameSession/player${otherPlayerNum}`).on('value', (snapshot) => {
    // Only update if we're still logged in
    if (!isLoggedIn) return;
    
    const otherPlayerData = snapshot.val();
    const wasConnected = otherPlayerConnected;
    
    if (otherPlayerData) {
      otherPlayerConnected = otherPlayerData.connected === true;
      updateConnectionStatus(otherPlayerData);
      
      if (!wasConnected && otherPlayerConnected) {
        showTemporaryNotification('BOTH PLAYERS CONNECTED!', '#00ff00', 3000);
      }
    } else {
      otherPlayerConnected = false;
      updateConnectionStatus(null);
    }
  });
  
  // Store the listener reference
  window.firebaseListeners.push({
    ref: database.ref(`gameSession/player${otherPlayerNum}`),
    callback: otherPlayerListener
  });

  // Listen for game state changes
  const gameStateListener = database.ref('gameSession/gameState').on('value', (snapshot) => {
    if (!isLoggedIn) return;
    if (snapshot.val()) {
      gameState = { ...gameState, ...snapshot.val() };
      updateGameDisplay();
    }
  });
  
  window.firebaseListeners.push({
    ref: database.ref('gameSession/gameState'),
    callback: gameStateListener
  });

  // Listen for current player changes
  const currentPlayerListener = database.ref('gameSession/currentPlayer').on('value', (snapshot) => {
    if (!isLoggedIn) return;
    if (snapshot.val()) {
      currentPlayer = snapshot.val();
      gameState.currentPlayer = snapshot.val();
      updatePlayerNames();
    }
  });
  
  window.firebaseListeners.push({
    ref: database.ref('gameSession/currentPlayer'),
    callback: currentPlayerListener
  });

  // Listen for chat messages
  const messagesListener = database.ref('gameSession/messages').on('value', (snapshot) => {
    if (!isLoggedIn) return;
    const messages = snapshot.val();
    if (messages) {
      gameMessages = Object.keys(messages).map(key => ({
        ...messages[key],
        id: key
      }));
    } else {
      gameMessages = [];
    }
    
    console.log(`Received ${gameMessages.length} messages from Firebase`);
    displayMessages();
    saveData();
  });
  
  window.firebaseListeners.push({
    ref: database.ref('gameSession/messages'),
    callback: messagesListener
  });

  // Listen for new messages to show notifications
  const messageNotificationListener = database.ref('gameSession/messages').on('child_added', (snapshot) => {
    if (!isLoggedIn) return;
    const message = snapshot.val();
    
    if (message && message.senderNumber !== myPlayerNumber && gameMessages.length > 0) {
      const notificationDiv = document.createElement('div');
      notificationDiv.style.cssText = `position: fixed; top: 60px; right: 20px; 
        background: rgba(0, 51, 0, 0.95); border: 2px solid #00ff00; padding: 10px; 
        color: #00ff00; text-shadow: 0 0 5px #00ff00; font-family: 'Orbitron', monospace; 
        font-size: 0.8em; z-index: 10000; max-width: 200px; border-radius: 3px;
        animation: slideIn 0.3s ease-out;`;
      
      notificationDiv.innerHTML = `<strong>NEW MESSAGE</strong><br>${message.sender}: ${message.text.substring(0, 30)}${message.text.length > 30 ? '...' : ''}`;
      document.body.appendChild(notificationDiv);
      
      notificationDiv.onclick = () => notificationDiv.remove();
      setTimeout(() => { 
        if (notificationDiv.parentNode) notificationDiv.remove(); 
      }, 3000);
    }
  });

  // Listen for game results
  const gameResultListener = database.ref('gameSession/gameResult').on('value', (snapshot) => {
    if (!isLoggedIn) return;
    const result = snapshot.val();
    if (result && !gameResultHandled) {
      gameResultHandled = true;
      setTimeout(() => {
        showGameResult(result.winner, result.message, result.score, result.gameSpecificData);
        // Clear the result after handling
        database.ref('gameSession/gameResult').remove();
        gameResultHandled = false;
      }, 500);
    }
  });

  window.firebaseListeners.push({
    ref: database.ref('gameSession/gameResult'),
    callback: gameResultListener
  });

  // Keep connection alive
  const heartbeat = setInterval(() => {
    if (isLoggedIn) {
      playerRef.child('lastSeen').set(firebase.database.ServerValue.TIMESTAMP);
    } else {
      clearInterval(heartbeat);
    }
  }, 30000);

  // Store heartbeat for cleanup
  window.currentHeartbeat = heartbeat;
}

function showTemporaryNotification(message, color = '#00ff00', duration = 3000) {
  const notificationDiv = document.createElement('div');
  notificationDiv.style.cssText = `position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(0, 51, 0, 0.95); border: 2px solid ${color}; padding: 15px; 
    color: ${color}; text-shadow: 0 0 10px ${color}; font-family: 'Orbitron', monospace; 
    font-weight: bold; text-transform: uppercase; z-index: 10001; border-radius: 3px;
    animation: slideDown 0.3s ease-out;`;
  
  // Add slide-down animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideDown {
      from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
  `;
  if (!document.querySelector('style[data-slidedown]')) {
    style.setAttribute('data-slidedown', 'true');
    document.head.appendChild(style);
  }
  
  notificationDiv.textContent = message;
  document.body.appendChild(notificationDiv);
  
  // Auto-remove after specified duration
  setTimeout(() => { 
    if (notificationDiv.parentNode) {
      notificationDiv.style.animation = 'slideDown 0.3s ease-out reverse';
      setTimeout(() => notificationDiv.remove(), 300);
    }
  }, duration);
}

function syncGameResult(winner, message, score = null, gameSpecificData = null) {
  if (myPlayerNumber) {
    database.ref('gameSession/gameResult').set({
      winner: winner,
      message: message,
      score: score,
      gameSpecificData: gameSpecificData,
      timestamp: Date.now()
    });
  }
}

// MOVE THESE OUTSIDE - they should be global functions
function updateConnectionStatus(otherPlayerData) {
  const statusDiv = document.getElementById('connectionStatus') || createStatusDiv();
  
  if (!otherPlayerConnected || !otherPlayerData) {
    const otherPlayerNum = myPlayerNumber === 1 ? 2 : 1;
    statusDiv.textContent = `WAITING FOR PLAYER ${otherPlayerNum}...`;
    statusDiv.style.color = '#ffff00';
    statusDiv.style.borderColor = '#ffff00';
    //update panel vis when status changes 
    updatePanelVisibility();
    return;
  }
  
  // Get player names
  const myName = document.getElementById(`player${myPlayerNumber}Name`).value.toUpperCase();
  const otherName = otherPlayerData.name || `PLAYER ${myPlayerNumber === 1 ? 2 : 1}`;
  
  // Get other player's location
  const otherLocation = otherPlayerData.location || 'lobby';
  let locationText;
  
  if (otherLocation === 'lobby') {
    locationText = 'IN LOBBY';
  } else {
    // Convert game type to readable name
    const gameNames = {
      'connect4': 'CONNECT 4',
      'tictactoe': 'TIC TAC TOE',
      'anagrams': 'ANAGRAMS',
      'memory': 'MEMORY MATCH',
      'mathrace': 'MATH RACE',
      'drawguess': 'DRAW & GUESS',
      'dicerace': 'DICE RACE',
      'sequence': 'SEQUENCE MEMORY',
      'wordchain': 'WORD CHAIN',
      'quickdraw': 'QUICK DRAW'
    };
    locationText = `IN ${gameNames[otherLocation] || otherLocation.toUpperCase()}`;
  }
  
  statusDiv.textContent = `${otherName} ${locationText}`;
  statusDiv.style.color = '#00ffff';
  statusDiv.style.borderColor = '#00ffff';

  updatePanelVisibility();
}

function createStatusDiv() {
  const statusDiv = document.createElement('div');
  statusDiv.id = 'connectionStatus';
  statusDiv.style.cssText = `position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
    background: rgba(0, 17, 0, 0.95); border: 2px solid #ffff00; padding: 10px 20px; 
    color: #ffff00; text-shadow: 0 0 10px #ffff00; font-family: 'Orbitron', monospace; 
    font-weight: bold; text-transform: uppercase; z-index: 10000; text-align: center;`;
  document.body.appendChild(statusDiv);
  return statusDiv;
}

function syncGameState() {
  if (myPlayerNumber) {
    database.ref('gameSession').update({
      gameState: gameState,
      currentPlayer: gameState.currentPlayer || currentPlayer,
      currentGame: currentGame
    }).catch(error => {
      console.error('Failed to sync game state:', error);
      // Show user-friendly error
      const errorDiv = document.createElement('div');
      errorDiv.style.cssText = `position: fixed; top: 20px; right: 20px; background: rgba(51, 0, 0, 0.95);
        border: 2px solid #ff0000; padding: 15px; color: #ff0000; text-shadow: 0 0 10px #ff0000;
        font-family: 'Orbitron', monospace; font-weight: bold; text-transform: uppercase; z-index: 10000;`;
      errorDiv.textContent = 'CONNECTION ERROR - RETRYING...';
      document.body.appendChild(errorDiv);
      setTimeout(() => { if (errorDiv.parentNode) errorDiv.remove(); }, 3000);
    });
  }
}

function updatePlayerLocation(location) {
  if (myPlayerNumber) {
    database.ref(`gameSession/player${myPlayerNumber}`).update({
      location: location,
      lastSeen: firebase.database.ServerValue.TIMESTAMP
    });
  }
}
  
function updateGameDisplay() {
  if (!currentGame) return;
  
  switch(currentGame) {
    case 'connect4':
      updateConnect4Display();
      break;
      
    case 'tictactoe':
      updateTicTacToeDisplay();
      break;
      
    case 'anagrams':
      if (gameState.currentLetters) {
        document.getElementById('anagramLetters').textContent = gameState.currentLetters;
      }
      if (gameState.player1Score !== undefined) {
        const resultDiv = document.getElementById('anagramResult');
        if (gameState.turn === 2 && gameState.player1Score > 0) {
          resultDiv.innerHTML = `<p>PLAYER 1 SCORED ${gameState.player1Score} POINTS</p><p>PLAYER 2'S TURN!</p>`;
        } else if (gameState.player2Score !== undefined) {
          const winner = gameState.player1Score > gameState.player2Score ? 1 : gameState.player2Score > gameState.player1Score ? 2 : 0;
          let resultText = `FINAL SCORES: P1: ${gameState.player1Score}, P2: ${gameState.player2Score}<br>`;
          if (winner === 0) resultText += "DRAW RESULT";
          else resultText += `PLAYER ${winner} VICTORY!`;
          resultDiv.innerHTML = resultText;
        }
      }
      break;
      
    case 'memory':
      updateMemoryDisplay();
      break;
      
    case 'mathrace':
      if (gameState.currentProblem) {
        document.getElementById('mathProblem').textContent = `${gameState.currentProblem.problem} = ?`;
      }
      if (gameState.score !== undefined) {
        document.getElementById('mathScore').textContent = `SCORE: ${gameState.score}`;
      }
      if (gameState.timeLeft !== undefined) {
        document.getElementById('mathTimer').textContent = gameState.timeLeft;
      }
      break;
      
    case 'dicerace':
      updateDiceScores();
      if (gameState.lastRoll) {
        const diceSymbols = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
        document.getElementById('diceDisplay').textContent = diceSymbols[gameState.lastRoll - 1];
      }
      break;
      
    case 'sequence':
      if (gameState.round) {
        document.getElementById('sequenceScore').textContent = `ROUND: ${gameState.round}`;
      }
      if (gameState.sequence && gameState.showingSequence) {
        showSequence();
      }
      break;
      
    case 'wordchain':
      if (gameState.wordChain && gameState.wordChain.length > 0) {
        document.getElementById('chainDisplay').innerHTML = `<strong>CHAIN:</strong> ${gameState.wordChain.join(' → ')}`;
        const lastWord = gameState.wordChain[gameState.wordChain.length - 1];
        const nextLetter = lastWord.slice(-1);
        document.getElementById('chainResult').innerHTML = `<p>NEXT WORD MUST START WITH "${nextLetter}"</p>`;
      }
      break;
      
    case 'drawguess':
      if (gameState.currentPrompt) {
        document.getElementById('drawPrompt').textContent = gameState.currentPrompt;
      }
      break;
      
    case 'quickdraw':
      if (gameState.currentPrompt) {
        document.getElementById('quickDrawPrompt').textContent = gameState.currentPrompt;
      }
      if (gameState.timeLeft !== undefined) {
        document.getElementById('quickDrawTimer').textContent = gameState.timeLeft;
      }
      break;
  }
}

function updateMemoryDisplay() {
  if (!gameState.cards) return;
  
  const cards = document.querySelectorAll('#memoryGrid .number-button');
  cards.forEach((card, index) => {
    if (gameState.matched && gameState.matched.includes(index)) {
      card.textContent = gameState.cards[index];
      card.classList.add('selected');
    } else if (gameState.flipped && gameState.flipped.includes(index)) {
      card.textContent = gameState.cards[index];
      card.classList.add('selected');
    } else {
      card.textContent = '?';
      card.classList.remove('selected');
    }
  });
  
  updateMemoryScore();
}
  
// non firebase functions below 


function startActivityMonitor() {
  lastActivityTime = Date.now();
  resetActivityTimeout();
  const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];
  events.forEach(event => document.addEventListener(event, updateActivity, true));
}

function updateActivity() {
  if (!isLoggedIn) return;
  lastActivityTime = Date.now();
  resetActivityTimeout();
}

function resetActivityTimeout() {
  clearTimeout(activityTimeout);
  activityTimeout = setTimeout(showTimeoutWarning, TIMEOUT_DURATION);
}

function showTimeoutWarning() {
  if (!isLoggedIn) return;
  const warningDiv = document.createElement('div');
  warningDiv.id = 'timeoutWarning';
  warningDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: rgba(0, 17, 0, 0.98); border: 4px solid #ff0040; padding: 30px; z-index: 10000; 
    text-align: center; box-shadow: 0 0 30px #ff0040; animation: pulse 1s infinite;`;
  warningDiv.innerHTML = `
    <h2 style="color: #ff0040; text-shadow: 0 0 15px #ff0040; margin-bottom: 20px; text-transform: uppercase;">
      SESSION TIMEOUT WARNING</h2>
    <p style="color: #ffff00; text-shadow: 0 0 10px #ffff00; margin-bottom: 25px; font-size: 1.1em;">
      ARE YOU STILL PLAYING?<br>SESSION WILL TERMINATE IN 30 SECONDS</p>
    <button onclick="continueSession()" style="background: #003300; color: #00ff00; border: 2px solid #00ff00;
      padding: 12px 25px; margin: 0 10px; font-family: 'Orbitron', monospace; font-weight: bold; 
      text-transform: uppercase; cursor: pointer; text-shadow: 0 0 5px #00ff00;">YES - CONTINUE</button>
    <button onclick="endSession()" style="background: #330000; color: #ff0000; border: 2px solid #ff0000;
      padding: 12px 25px; margin: 0 10px; font-family: 'Orbitron', monospace; font-weight: bold; 
      text-transform: uppercase; cursor: pointer; text-shadow: 0 0 5px #ff0000;">NO - LOGOUT</button>
    <div id="timeoutCountdown" style="color: #ff0040; font-size: 1.5em; font-weight: bold;
      text-shadow: 0 0 10px #ff0040; margin-top: 20px;">30</div>`;
  document.body.appendChild(warningDiv);
  
  let countdown = 30;
  const countdownInterval = setInterval(() => {
    countdown--;
    const countdownEl = document.getElementById('timeoutCountdown');
    if (countdownEl) countdownEl.textContent = countdown;
    if (countdown <= 0) { clearInterval(countdownInterval); endSession(); }
  }, 1000);
  warningDiv.countdownInterval = countdownInterval;
}

window.continueSession = function() {
  const warningDiv = document.getElementById('timeoutWarning');
  if (warningDiv) {
    if (warningDiv.countdownInterval) clearInterval(warningDiv.countdownInterval);
    warningDiv.remove();
  }
  updateActivity();
}

window.endSession = function() {
  // Set logged out FIRST
  isLoggedIn = false;
  
  const warningDiv = document.getElementById('timeoutWarning');
  if (warningDiv) {
    if (warningDiv.countdownInterval) clearInterval(warningDiv.countdownInterval);
    warningDiv.remove();
  }
  
  // Clean up Firebase connection
  if (myPlayerNumber) {
    database.ref(`gameSession/player${myPlayerNumber}`).update({
      connected: false,
      lastSeen: firebase.database.ServerValue.TIMESTAMP
    });
  }
  
  // Remove ALL Firebase listeners
  if (window.firebaseListeners) {
    window.firebaseListeners.forEach(listener => {
      listener.ref.off('value', listener.callback);
      listener.ref.off('child_added', listener.callback);
    });
    window.firebaseListeners = [];
  }
  
  database.ref().off();
  
  // Clear heartbeat
  if (window.currentHeartbeat) {
    clearInterval(window.currentHeartbeat);
    window.currentHeartbeat = null;
  }
  
  clearTimeout(activityTimeout);
  currentGame = null;
  gameState = {};
  gameMessages = [];
  myPlayerNumber = null; 
  otherPlayerConnected = false; 
  
  // Remove connection status div
  const statusDiv = document.getElementById('connectionStatus');
  if (statusDiv) statusDiv.remove(); 
  
  document.getElementById('loginScreen').style.display = 'block';
  document.getElementById('gameContainer').style.display = 'none';
  document.getElementById('passwordInput').value = '';
  
  const logoutDiv = document.createElement('div');
  logoutDiv.style.cssText = `position: fixed; top: 20px; right: 20px; background: rgba(51, 0, 0, 0.95);
    border: 2px solid #ff0040; padding: 15px; color: #ff0040; text-shadow: 0 0 10px #ff0040;
    font-family: 'Orbitron', monospace; font-weight: bold; text-transform: uppercase; z-index: 10000;`;
  logoutDiv.textContent = 'SESSION TERMINATED - INACTIVITY TIMEOUT';
  document.body.appendChild(logoutDiv);
  setTimeout(() => { if (logoutDiv.parentNode) logoutDiv.remove(); }, 5000);
}

// Game state
let currentGame = null;
let currentPlayer = 1;
let gameState = {};
let gameHistory = {};
let globalScores = { player1: 0, player2: 0 };
let gameMessages = [];



function updatePlayerNames() {
  const player1 = (document.getElementById('player1Name').value || 'ELENA').toUpperCase();
  const player2 = (document.getElementById('player2Name').value || 'BRYAN').toUpperCase();
  document.getElementById('player1GlobalScore').textContent = `${player1}: ${globalScores.player1} WINS`;
  document.getElementById('player2GlobalScore').textContent = `${player2}: ${globalScores.player2} WINS`;
  if (currentGame) {
    const currentPlayerName = currentPlayer === 1 ? player1 : player2;
    document.getElementById('currentPlayer').textContent = `ACTIVE: ${currentPlayerName}`;
  }
}

function startGame(gameType) {
  // Only allow starting games if other player is connected
  if (!otherPlayerConnected) {
    alert('WAITING FOR OTHER PLAYER TO CONNECT');
    return;
  }
  
  currentGame = gameType;
  currentPlayer = 1;
  gameState = {currentPlayer: 1};
 
  document.getElementById('gamesGrid').style.display = 'none';
  document.getElementById('gameArea').style.display = 'block';
  document.getElementById('historyPanel').style.display = 'block';
  document.getElementById('messagesPanel').style.display = 'block';
  updatePlayerNames();
  syncGameState();
  loadGameHistory(gameType);
 
  const gameConfig = getGameConfig(gameType);
  document.getElementById('gameTitle').textContent = gameConfig.title;
  document.getElementById('gameContent').innerHTML = gameConfig.html;
  if (gameConfig.init) gameConfig.init();

  updatePlayerLocation(gameType);
}

function updatePanelVisibility() {
  const historyPanel = document.getElementById('historyPanel');
  const messagesPanel = document.getElementById('messagesPanel');
  
  if (otherPlayerConnected) {
    // If both players are connected, always show chat
    messagesPanel.style.display = 'block';
    
    // Show history panel if in a game, or show placeholder if in lobby
    if (currentGame) {
      historyPanel.style.display = 'block';
      loadGameHistory(currentGame);
    } else {
      historyPanel.style.display = 'block';
      document.getElementById('historyContent').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">SELECT A GAME TO VIEW HISTORY</p>';
    }
  } else {
    // If other player isn't connected, hide both panels
    historyPanel.style.display = 'none';
    messagesPanel.style.display = 'none';
  }
}

function backToMenu() {
  currentGame = null;
  
  // Always show the games grid
  document.getElementById('gamesGrid').style.display = 'grid';
  document.getElementById('gameArea').style.display = 'none';
  
  // Only hide chat and history if other player isn't connected
  // If other player is connected, keep them visible for communication
  if (!otherPlayerConnected) {
    document.getElementById('historyPanel').style.display = 'none';
    document.getElementById('messagesPanel').style.display = 'none';
  } else {
    // Keep panels visible but clear the history since we're not in a specific game
    document.getElementById('historyPanel').style.display = 'block';
    document.getElementById('messagesPanel').style.display = 'block';
    
    // Clear game-specific history but keep the panels
    document.getElementById('historyContent').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">SELECT A GAME TO VIEW HISTORY</p>';
  }
  
  // Update location to lobby
  updatePlayerLocation('lobby');
}

function switchPlayer() {
  currentPlayer = currentPlayer === 1 ? 2 : 1;
  gameState.currentPlayer = currentPlayer;
  updatePlayerNames();
  syncGameState();

}

function recordWin(winner, score = null, gameSpecificData = null) {
  if (!gameHistory[currentGame]) gameHistory[currentGame] = [];
  const player1Name = (document.getElementById('player1Name').value || 'ELENA').toUpperCase();
  const player2Name = (document.getElementById('player2Name').value || 'BRYAN').toUpperCase();
  const winnerName = winner === 1 ? player1Name : player2Name;
  const gameRecord = {
    winner: winnerName, date: new Date().toLocaleDateString(), 
    time: new Date().toLocaleTimeString(), score: score, ...gameSpecificData
  };
  gameHistory[currentGame].unshift(gameRecord);
  if (gameHistory[currentGame].length > 10) {
    gameHistory[currentGame] = gameHistory[currentGame].slice(0, 10);
  }
  globalScores[`player${winner}`]++;
  updateGlobalScores();
  loadGameHistory(currentGame);
  saveData();
}

function updateGlobalScores() { updatePlayerNames(); }

function loadGameHistory(gameType) {
  const historyContent = document.getElementById('historyContent');
  const history = gameHistory[gameType] || [];
  if (history.length === 0) {
    historyContent.innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">NO RECORDS FOUND</p>';
    return;
  }
  historyContent.innerHTML = history.map(record => {
    let scoreText = record.score !== null ? ` - SCORE: ${record.score}` : '';
    return `<div style="margin-bottom: 10px; padding: 8px; border-left: 3px solid #ffff00; background: rgba(255, 255, 0, 0.05); color: #00ff00;">
      <div style="color: #ffff00; font-weight: bold; text-shadow: 0 0 5px #ffff00;">${record.winner} VICTORY${scoreText}</div>
      <div style="color: #00ffff; font-size: 0.8em; text-shadow: 0 0 3px #00ffff;">${record.date} ${record.time}</div>
    </div>`;
  }).join('');
}


function getGameConfig(gameType) {
  const configs = {
    connect4: { title: '█ CONNECT 4', 
      html: '<div class="connect4-board" id="connect4Board"></div><div class="game-info">SELECT COLUMN TO DROP PIECE</div>',
      init: initConnect4 },
    tictactoe: { title: '█ TIC TAC TOE',
      html: '<div class="tic-tac-toe-board" id="ticTacToeBoard"></div><div class="game-info">SELECT GRID POSITION</div>',
      init: initTicTacToe },
    anagrams: { title: '█ ANAGRAMS',
      html: `<div class="game-info"><h3 style="color: #00ffff; text-shadow: 0 0 10px #00ffff;">LETTERS: <span id="anagramLetters"></span></h3>
        <p>PLAYER 1 GOES FIRST, THEN PLAYER 2 ATTEMPTS TO BEAT SCORE</p></div>
        <input type="text" class="word-input" id="anagramInput" placeholder="ENTER WORD">
        <div style="text-align: center;"><button class="submit-button" onclick="submitAnagram()">SUBMIT</button></div>
        <div id="anagramResult" style="text-align: center; color: #ffff00; text-shadow: 0 0 10px #ffff00; margin-top: 15px;"></div>`,
      init: initAnagrams },
    memory: { title: '█ MEMORY MATCH',
      html: '<div class="number-grid" id="memoryGrid"></div><div class="game-info">LOCATE ALL MATCHING PAIRS</div><div id="memoryScore" style="text-align: center; color: #ffff00; text-shadow: 0 0 10px #ffff00;">MOVES: 0</div>',
      init: initMemory },
    mathrace: { title: '█ MATH RACE',
      html: `<div class="math-problem" id="mathProblem" style="font-size: 2em; text-align: center; margin: 20px 0; color: #00ffff; text-shadow: 0 0 15px #00ffff;"></div>
        <input type="number" class="math-input" id="mathInput" placeholder="ENTER ANSWER">
        <div style="text-align: center;"><button class="submit-button" onclick="submitMath()">SUBMIT</button></div>
        <div id="mathScore" style="text-align: center; color: #ffff00; text-shadow: 0 0 10px #ffff00; font-size: 1.2em;">SCORE: 0</div>
        <div class="timer" id="mathTimer">60</div>`,
      init: initMathRace },
    drawguess: { title: '█ DRAW & GUESS',
      html: `<div class="game-info"><h3 style="color: #00ffff; text-shadow: 0 0 10px #00ffff;">DRAW: <span id="drawPrompt"></span></h3>
        <p>ONE PLAYER DRAWS, OTHER GUESSES</p></div>
        <div class="color-palette">
          <div class="color-button active" style="background: black" onclick="selectColor('black', event)"></div>
          <div class="color-button" style="background: #ff0040" onclick="selectColor('#ff0040', event)"></div>
          <div class="color-button" style="background: #00ffff" onclick="selectColor('#00ffff', event)"></div>
          <div class="color-button" style="background: #00ff00" onclick="selectColor('#00ff00', event)"></div>
          <div class="color-button" style="background: #ffff00" onclick="selectColor('#ffff00', event)"></div>
        </div><canvas id="drawCanvas" class="drawing-canvas" width="400" height="300"></canvas>
        <div style="text-align: center; margin-top: 15px;">
          <button class="submit-button" onclick="clearCanvas()">CLEAR</button>
          <button class="submit-button" onclick="nextDrawRound()">NEXT ROUND</button>
        </div>`,
      init: initDrawGuess },
    dicerace: { title: '█ DICE RACE',
      html: `<div class="game-info">FIRST TO REACH 50 POINTS WINS</div>
        <div class="dice" id="diceDisplay">█</div>
        <div style="text-align: center;"><button class="roll-button" onclick="rollDice()">ROLL DICE</button></div>
        <div id="diceScores" style="text-align: center; font-size: 1.5em; margin: 20px 0; color: #ffff00; text-shadow: 0 0 15px #ffff00;"></div>`,
      init: initDiceRace },
    sequence: { title: '█ SEQUENCE MEMORY',
      html: `<div class="game-info">WATCH SEQUENCE, THEN REPEAT</div>
        <div class="sequence-display" id="sequenceDisplay" style="min-height: 40px; text-align: center; margin-bottom: 20px;"></div>
        <div class="number-grid" id="sequenceGrid"></div>
        <div id="sequenceScore" style="text-align: center; color: #ffff00; text-shadow: 0 0 10px #ffff00;">ROUND: 1</div>
        <div style="text-align: center; margin-top: 15px;"><button class="submit-button" onclick="startSequenceRound()">START ROUND</button></div>`,
      init: initSequence },
    wordchain: { title: '█ WORD CHAIN',
      html: `<div class="game-info"><p>CREATE WORD CHAIN - EACH WORD STARTS WITH LAST LETTER OF PREVIOUS</p>
        <div id="chainDisplay" style="margin: 15px 0; color: #00ffff; text-shadow: 0 0 10px #00ffff;">START WITH ANY WORD</div></div>
        <input type="text" class="wordchain-input" id="chainInput" placeholder="ENTER WORD">
        <div style="text-align: center;"><button class="submit-button" onclick="submitChainWord()">SUBMIT</button></div>
        <div id="chainResult" style="text-align: center; color: #ffff00; text-shadow: 0 0 10px #ffff00; margin-top: 15px;"></div>`,
      init: initWordChain },
    quickdraw: { title: '█ QUICK DRAW',
      html: `<div class="game-info"><h3 style="color: #00ffff; text-shadow: 0 0 10px #00ffff;">DRAW: <span id="quickDrawPrompt"></span></h3>
        <p>TIME LIMIT: 30 SECONDS</p></div>
        <canvas id="quickDrawCanvas" class="drawing-canvas" width="400" height="300"></canvas>
        <div class="timer" id="quickDrawTimer">30</div>
        <div style="text-align: center; margin-top: 15px;">
          <button class="submit-button" onclick="startQuickDraw()">START TIMER</button>
          <button class="submit-button" onclick="nextQuickDraw()">NEXT PLAYER</button>
        </div>`,
      init: initQuickDraw }
  };
  return configs[gameType];
}

// Profile picture functionality
let profilePictures = { player1: null, player2: null };
let secretClickCount = 0;
let secretTimer = null;

function selectProfilePicture(playerNumber) {
  document.getElementById(`fileInput${playerNumber}`).click();
}

function handleProfileUpload(playerNumber, event) {
  const file = event.target.files[0];
  if (!file) return;
  
  // Validate file size (max 2MB)
  if (file.size > 2 * 1024 * 1024) {
    alert('FILE TOO LARGE - MAXIMUM 2MB ALLOWED');
    return;
  }
  
  // Validate file type
  if (!file.type.startsWith('image/')) {
    alert('INVALID FILE TYPE - IMAGES ONLY');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const imageData = e.target.result;
    profilePictures[`player${playerNumber}`] = imageData;
    
    // Update display
    const profileDiv = document.getElementById(`profile${playerNumber}`);
    profileDiv.innerHTML = `<img src="${imageData}" alt="Player ${playerNumber}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
    profileDiv.classList.remove('placeholder');
    
    // Save to storage
    saveData();
    
    // Show success message
    const successDiv = document.createElement('div');
    successDiv.style.cssText = `position: fixed; top: 80px; right: 20px; 
      background: rgba(0, 51, 0, 0.95); border: 2px solid #00ff00; padding: 10px; 
      color: #00ff00; text-shadow: 0 0 5px #00ff00; font-family: 'Orbitron', monospace; 
      font-size: 0.8em; z-index: 10000; text-transform: uppercase;`;
    successDiv.textContent = `PLAYER ${playerNumber} PROFILE UPDATED`;
    document.body.appendChild(successDiv);
    
    setTimeout(() => { 
      if (successDiv.parentNode) successDiv.remove(); 
    }, 2000);
  };
  
  reader.readAsDataURL(file);
}

function loadProfilePictures() {
  // Load from saved data
  if (window.gameData && window.gameData.profilePictures) {
    profilePictures = { ...window.gameData.profilePictures };
    
    // Update displays
    for (let i = 1; i <= 2; i++) {
      const imageData = profilePictures[`player${i}`];
      if (imageData) {
        const profileDiv = document.getElementById(`profile${i}`);
        profileDiv.innerHTML = `<img src="${imageData}" alt="Player ${i}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">`;
        profileDiv.classList.remove('placeholder');
      }
    }
  }
}

// Secret reset functionality
function handleSecretClick() {
  secretClickCount++;
  
  // Reset timer
  if (secretTimer) clearTimeout(secretTimer);
  secretTimer = setTimeout(() => {
    secretClickCount = 0;
  }, 3000);
  
  // Check for secret sequence (7 clicks within 3 seconds)
  if (secretClickCount >= 7) {
    confirmScoreboardReset();
    secretClickCount = 0;
  }
}

function confirmScoreboardReset() {
  const resetOverlay = document.createElement('div');
  resetOverlay.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center;
    z-index: 10002;`;
  
  const resetDialog = document.createElement('div');
  resetDialog.style.cssText = `background: rgba(51, 0, 0, 0.98); border: 4px solid #ff0040;
    padding: 40px; text-align: center; max-width: 500px; box-shadow: 0 0 50px #ff0040;`;
  
  resetDialog.innerHTML = `
    <h2 style="color: #ff0040; text-shadow: 0 0 15px #ff0040; margin-bottom: 20px; text-transform: uppercase;">
      [ADMIN MODE DETECTED]</h2>
    <p style="color: #ffff00; text-shadow: 0 0 10px #ffff00; margin-bottom: 30px;">
      WARNING: THIS WILL RESET ALL SCORES AND GAME HISTORY<br>
      THIS ACTION CANNOT BE UNDONE</p>
    <div style="display: flex; gap: 20px; justify-content: center;">
      <button onclick="executeReset()" style="background: #330000; color: #ff0040; border: 2px solid #ff0040;
        padding: 12px 25px; font-family: 'Orbitron', monospace; font-weight: bold; 
        text-transform: uppercase; cursor: pointer;">CONFIRM RESET</button>
      <button onclick="cancelReset()" style="background: #003300; color: #00ff00; border: 2px solid #00ff00;
        padding: 12px 25px; font-family: 'Orbitron', monospace; font-weight: bold; 
        text-transform: uppercase; cursor: pointer;">CANCEL</button>
    </div>
  `;
  
  resetOverlay.appendChild(resetDialog);
  resetOverlay.id = 'resetOverlay';
  document.body.appendChild(resetOverlay);
}

function executeReset() {
  // Reset all game data
  globalScores = { player1: 0, player2: 0 };
  gameHistory = {};
  gameMessages = [];
  
  // Clear Firebase
  if (myPlayerNumber) {
    database.ref('gameSession/messages').remove();
  }
  
  // Clear local storage
  sessionStorage.removeItem('gameHubData');
  window.gameData = null;
  
  // Update displays
  updateGlobalScores();
  document.getElementById('historyContent').innerHTML = '<p style="text-align: center; color: #666; font-style: italic;">NO RECORDS FOUND</p>';
  displayMessages();
  
  // Close dialog
  cancelReset();
  
  // Show confirmation
  const confirmDiv = document.createElement('div');
  confirmDiv.style.cssText = `position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(51, 0, 0, 0.95); border: 2px solid #ff0040; padding: 15px; 
    color: #ff0040; text-shadow: 0 0 10px #ff0040; font-family: 'Orbitron', monospace; 
    font-weight: bold; text-transform: uppercase; z-index: 10000;`;
  confirmDiv.textContent = 'SCOREBOARD RESET COMPLETE';
  document.body.appendChild(confirmDiv);
  
  setTimeout(() => { 
    if (confirmDiv.parentNode) confirmDiv.remove(); 
  }, 3000);
}

function cancelReset() {
  const overlay = document.getElementById('resetOverlay');
  if (overlay) overlay.remove();
}

// Make functions globally accessible
window.selectProfilePicture = selectProfilePicture;
window.handleProfileUpload = handleProfileUpload;
window.handleSecretClick = handleSecretClick;
window.executeReset = executeReset;
window.cancelReset = cancelReset;

// Result screen triggers 
function showGameResult(winner, message, score = null, gameSpecificData = null) {
  // Determine if current player won, lost, or drew
  let screenType, title, resultMessage;
  
  if (winner === 0) {
    screenType = 'draw';
    title = 'DRAW';
    resultMessage = 'HONORABLE STALEMATE';
  } else if (winner === myPlayerNumber) {
    screenType = 'winner';
    title = 'WOOOOHOOOOO';
    resultMessage = '🐛🧚 WINNA WINNA CHIKIN DINNA 🐛🧚';
  } else {
    screenType = 'loser';
    title = 'U R A LOSER';
    resultMessage = '😭🫵🏻 GO HOME AND CRY ABOUT IT 😭🫵🏻';
  }
  
  // Get player names
  const player1Name = (document.getElementById('player1Name').value || 'ELENA').toUpperCase();
  const player2Name = (document.getElementById('player2Name').value || 'BRYAN').toUpperCase();
  const winnerName = winner === 1 ? player1Name : winner === 2 ? player2Name : null;
  
  // Create overlay
  const overlay = document.createElement('div');
  overlay.className = 'game-result-overlay';
  overlay.id = 'gameResultOverlay';
  
  // Create result screen
  const resultScreen = document.createElement('div');
  resultScreen.className = `result-screen ${screenType}-screen`;
  
  let statsHTML = '';
  if (score !== null) {
    statsHTML = `
      <div class="result-stats">
        <strong>FINAL SCORE: ${score}</strong>
      </div>
    `;
  }
  
  let winnerText = '';
  if (winner !== 0) {
    winnerText = `<div style="font-size: 1.5em; color: #00ffff; text-shadow: 0 0 15px #00ffff; margin-bottom: 20px;">
      ${winnerName} CURB STOMPED THE COMPETITION
    </div>`;
  }
  
  resultScreen.innerHTML = `
    <div class="result-title">${title}</div>
    ${winnerText}
    <div class="result-message">${resultMessage}</div>
    ${statsHTML}
    <div class="result-buttons">
      <button class="result-button" onclick="playAgain()">PLAY AGAIN</button>
      <button class="result-button secondary" onclick="returnToMenu()">MAIN MENU</button>
    </div>
  `;
  
  overlay.appendChild(resultScreen);
  document.body.appendChild(overlay);
  
  // Record win if needed
  if (winner !== 0) {
    recordWin(winner, score, gameSpecificData);
  }
  
  // Auto-dismiss after 10 seconds if no interaction
  setTimeout(() => {
    const existingOverlay = document.getElementById('gameResultOverlay');
    if (existingOverlay) {
      existingOverlay.style.opacity = '0.7';
      const autoCloseMsg = document.createElement('div');
      autoCloseMsg.style.cssText = `position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
        color: #666; font-size: 0.9em; text-align: center;`;
      autoCloseMsg.textContent = 'Auto-closing in 5 seconds...';
      existingOverlay.querySelector('.result-screen').appendChild(autoCloseMsg);
      
      setTimeout(() => {
        if (document.getElementById('gameResultOverlay')) {
          returnToMenu();
        }
      }, 5000);
    }
  }, 10000);
}

function playAgain() {
  closeResultScreen();
  restartGame();
}

function returnToMenu() {
  closeResultScreen();
  backToMenu();
}

function closeResultScreen() {
  const overlay = document.getElementById('gameResultOverlay');
  if (overlay) {
    overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
    setTimeout(() => overlay.remove(), 300);
  }
}

window.playAgain = playAgain;
window.returnToMenu = returnToMenu;

// Game implementations

// Game implementations - CORRECTED VERSION (no duplicates)

function initConnect4() {
  gameState.board = Array(6).fill().map(() => Array(7).fill(0));
  gameState.currentPlayer = 1;
  currentPlayer = 1;
  syncGameState(); 
  const board = document.getElementById('connect4Board');
  board.innerHTML = '';
  for (let row = 0; row < 6; row++) {
    for (let col = 0; col < 7; col++) {
      const cell = document.createElement('div');
      cell.className = 'connect4-cell';
      cell.onclick = () => dropPiece(col);
      board.appendChild(cell);
    }
  }
}

function dropPiece(col) {
  // Only allow moves if it's your turn and other player is connected
  if (!gameState.currentPlayer || gameState.currentPlayer !== myPlayerNumber || !otherPlayerConnected) return;
  
  for (let row = 5; row >= 0; row--) {
    if (gameState.board[row][col] === 0) {
      gameState.board[row][col] = gameState.currentPlayer;
      updateConnect4Display();
      if (checkConnect4Win(row, col)) {
        syncGameResult(gameState.currentPlayer, `PLAYER ${gameState.currentPlayer} VICTORY!`);
        return;
      }
      gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
      currentPlayer = gameState.currentPlayer;
      syncGameState();
      updatePlayerNames();
      break;
    }
  }
}

function updateConnect4Display() {
  const cells = document.querySelectorAll('.connect4-cell');
  for (let row = 0; row < 6; row++) {
    for (let col = 0; col < 7; col++) {
      const cell = cells[row * 7 + col];
      const value = gameState.board[row][col];
      cell.className = 'connect4-cell';
      if (value === 1) cell.classList.add('red');
      if (value === 2) cell.classList.add('yellow');
    }
  }
}

function checkConnect4Win(row, col) {
  const player = gameState.board[row][col];
  const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
  for (const [dx, dy] of directions) {
    let count = 1;
    for (let i = 1; i < 4; i++) {
      const newRow = row + dx * i, newCol = col + dy * i;
      if (newRow >= 0 && newRow < 6 && newCol >= 0 && newCol < 7 && gameState.board[newRow][newCol] === player) count++;
      else break;
    }
    for (let i = 1; i < 4; i++) {
      const newRow = row - dx * i, newCol = col - dy * i;
      if (newRow >= 0 && newRow < 6 && newCol >= 0 && newCol < 7 && gameState.board[newRow][newCol] === player) count++;
      else break;
    }
    if (count >= 4) return true;
  }
  return false;
}

function initTicTacToe() {
  gameState.board = Array(9).fill('');
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState(); 
  const board = document.getElementById('ticTacToeBoard');
  board.innerHTML = '';
  for (let i = 0; i < 9; i++) {
    const cell = document.createElement('div');
    cell.className = 'tic-tac-toe-cell';
    cell.onclick = () => placeMark(i);
    board.appendChild(cell);
  }
}

function placeMark(index) {
  // Only allow moves if it's your turn and other player is connected
 if (!gameState.currentPlayer || gameState.currentPlayer !== myPlayerNumber || !otherPlayerConnected) return;
  
  if (gameState.board[index] !== '') return;
  gameState.board[index] = gameState.currentPlayer === 1 ? 'X' : 'O';
  updateTicTacToeDisplay();
  if (checkTicTacToeWin()) {
    syncGameResult(gameState.currentPlayer, `PLAYER ${gameState.currentPlayer} VICTORY!`);
    return;
  }
  if (gameState.board.every(cell => cell !== '')) {
    syncGameResult(0, "DRAW - NO WINNER", null, null, false);
    return;
  }
  gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
  currentPlayer = gameState.currentPlayer;
  syncGameState();
  updatePlayerNames();
}

function updateTicTacToeDisplay() {
  const cells = document.querySelectorAll('.tic-tac-toe-cell');
  cells.forEach((cell, index) => { cell.textContent = gameState.board[index]; });
}

function checkTicTacToeWin() {
  const winPatterns = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];
  const mark = gameState.currentPlayer === 1 ? 'X' : 'O';
  return winPatterns.some(pattern => pattern.every(index => gameState.board[index] === mark));
}

function initAnagrams() {
  const letters = ['COMPUTER', 'ELEPHANT', 'RAINBOW', 'KITCHEN', 'MOUNTAIN', 'FLOWERS', 'BICYCLE', 'HARMONY'];
  gameState.currentLetters = letters[Math.floor(Math.random() * letters.length)];
  gameState.player1Score = 0;
  gameState.player2Score = 0;
  gameState.turn = 1;
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  document.getElementById('anagramLetters').textContent = gameState.currentLetters;
  document.getElementById('anagramInput').value = '';
  document.getElementById('anagramResult').innerHTML = '';
}

function submitAnagram() {
  // Only allow moves if it's your turn and other player is connected
  if (!gameState.currentPlayer || gameState.currentPlayer !== myPlayerNumber || !otherPlayerConnected) return;
  
  const word = document.getElementById('anagramInput').value.toUpperCase().trim();
  const letters = gameState.currentLetters;
  if (word.length < 3) { alert('MINIMUM 3 LETTERS REQUIRED'); return; }
  const letterCount = {};
  for (const letter of letters) letterCount[letter] = (letterCount[letter] || 0) + 1;
  for (const letter of word) {
    if (!letterCount[letter] || letterCount[letter] === 0) {
      alert('INVALID WORD - USES UNAVAILABLE LETTERS'); return;
    }
    letterCount[letter]--;
  }
  const score = word.length;
  if (gameState.turn === 1) {
    gameState.player1Score = score;
    gameState.turn = 2;
    gameState.currentPlayer = 2;
    updatePlayerNames();
    document.getElementById('anagramResult').innerHTML = `<p>PLAYER 1 SCORED ${score} POINTS WITH "${word}"</p><p>PLAYER 2'S TURN!</p>`;
    document.getElementById('anagramInput').value = '';
    syncGameState(); 
  } else {
    gameState.player2Score = score;
    const winner = gameState.player1Score > gameState.player2Score ? 1 : gameState.player2Score > gameState.player1Score ? 2 : 0;
    let resultText = `PLAYER 2 SCORED ${score} POINTS WITH "${word}"<br>FINAL SCORES: P1: ${gameState.player1Score}, P2: ${gameState.player2Score}<br>`;
    
    if (winner === 0) {
      resultText += "DRAW RESULT";
      syncGameResult(0, resultText, null, null, false);
    } else {
      resultText += `PLAYER ${winner} VICTORY!`;
      const winningScore = winner === 1 ? gameState.player1Score : gameState.player2Score;
      syncGameResult(winner, resultText, winningScore);
    }
    
    document.getElementById('anagramResult').innerHTML = resultText;
    syncGameState(); 
  }
}

function initMemory() {
  const numbers = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8];
  gameState.cards = numbers.sort(() => Math.random() - 0.5);
  gameState.flipped = [];
  gameState.matched = [];
  gameState.moves = 0;
  gameState.player1Matches = 0;
  gameState.player2Matches = 0;
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  const grid = document.getElementById('memoryGrid');
  grid.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const card = document.createElement('div');
    card.className = 'number-button';
    card.textContent = '?';
    card.onclick = () => flipCard(i);
    grid.appendChild(card);
  }
  updateMemoryScore();
}

function flipCard(index) {
  // Only allow moves if it's your turn and other player is connected
  if (currentPlayer !== myPlayerNumber || !otherPlayerConnected) return;
  
  if (gameState.flipped.length === 2 || gameState.flipped.includes(index) || gameState.matched.includes(index)) return;
  gameState.flipped.push(index);
  const cards = document.querySelectorAll('#memoryGrid .number-button');
  cards[index].textContent = gameState.cards[index];
  cards[index].classList.add('selected');
  if (gameState.flipped.length === 2) {
    gameState.moves++;
    updateMemoryScore();
    syncGameState(); 
    setTimeout(() => {
      const [first, second] = gameState.flipped;
      if (gameState.cards[first] === gameState.cards[second]) {
        gameState.matched.push(first, second);
        if (currentPlayer === 1) gameState.player1Matches++;
        else gameState.player2Matches++;
        if (gameState.matched.length === 16) {
          const winner = gameState.player1Matches > gameState.player2Matches ? 1 : gameState.player2Matches > gameState.player1Matches ? 2 : 0;
          setTimeout(() => {
            if (winner === 0) {
              syncGameResult(0, "DRAW RESULT", null, null, false);
            } else {
              const matches = winner === 1 ? gameState.player1Matches : gameState.player2Matches;
              syncGameResult(winner, `PLAYER ${winner} VICTORY WITH ${matches} MATCHES!`, matches);
            }
          }, 500);
        }
      } else {
        cards[first].textContent = '?';
        cards[second].textContent = '?';
        cards[first].classList.remove('selected');
        cards[second].classList.remove('selected');
        switchPlayer();
      }
      gameState.flipped = [];
      syncGameState(); 
    }, 1000);
  }
}

function updateMemoryScore() {
  const player1Name = (document.getElementById('player1Name').value || 'ELENA').toUpperCase();
  const player2Name = (document.getElementById('player2Name').value || 'BRYAN').toUpperCase();
  document.getElementById('memoryScore').innerHTML = `MOVES: ${gameState.moves} | ${player1Name}: ${gameState.player1Matches} | ${player2Name}: ${gameState.player2Matches}`;
}

function initMathRace() {
  gameState.score = 0;
  gameState.timeLeft = 60;
  gameState.currentProblem = generateMathProblem();
  gameState.gameActive = true;
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  displayMathProblem();
  startMathTimer();
}

function generateMathProblem() {
  const operations = ['+', '-', '*'];
  const op = operations[Math.floor(Math.random() * operations.length)];
  let a, b, answer;
  switch (op) {
    case '+': a = Math.floor(Math.random() * 50) + 1; b = Math.floor(Math.random() * 50) + 1; answer = a + b; break;
    case '-': a = Math.floor(Math.random() * 50) + 20; b = Math.floor(Math.random() * (a - 1)) + 1; answer = a - b; break;
    case '*': a = Math.floor(Math.random() * 12) + 1; b = Math.floor(Math.random() * 12) + 1; answer = a * b; break;
  }
  return { problem: `${a} ${op} ${b}`, answer };
}

function displayMathProblem() {
  document.getElementById('mathProblem').textContent = `${gameState.currentProblem.problem} = ?`;
  document.getElementById('mathInput').value = '';
}

function submitMath() {
  if (!gameState.gameActive) return;
  const userAnswer = parseInt(document.getElementById('mathInput').value);
  if (userAnswer === gameState.currentProblem.answer) {
    gameState.score++;
    gameState.currentProblem = generateMathProblem();
    displayMathProblem();
    document.getElementById('mathScore').textContent = `SCORE: ${gameState.score}`;
  } else {
    alert('INCORRECT - TRY AGAIN');
    document.getElementById('mathInput').value = '';
  }
}

function startMathTimer() {
  const timer = setInterval(() => {
    gameState.timeLeft--;
    document.getElementById('mathTimer').textContent = gameState.timeLeft;
    if (gameState.timeLeft <= 0) {
      clearInterval(timer);
      gameState.gameActive = false;
      alert(`TIME EXPIRED! PLAYER ${currentPlayer} SCORED ${gameState.score} POINTS!`);
      if (currentPlayer === 1) {
        gameState.player1FinalScore = gameState.score;
        currentPlayer = 2;
        switchPlayer();
        initMathRace();
      } else {
        const winner = gameState.player1FinalScore > gameState.score ? 1 : gameState.score > gameState.player1FinalScore ? 2 : 0;
        setTimeout(() => {
          if (winner === 0) {
            syncGameResult(0, "DRAW RESULT", null, null, false);
          } else {
            const winningScore = winner === 1 ? gameState.player1FinalScore : gameState.score;
            syncGameResult(winner, `PLAYER ${winner} VICTORY WITH ${winningScore} POINTS!`, winningScore);
          }
        }, 1000);
      }
    }
  }, 1000);
}

// Drawing games
let currentColor = 'black';
let isDrawing = false;

function initDrawGuess() {
  const prompts = ['CAT', 'HOUSE', 'CAR', 'TREE', 'SUN', 'FLOWER', 'FISH', 'BIRD', 'BOOK', 'APPLE'];
  gameState.currentPrompt = prompts[Math.floor(Math.random() * prompts.length)];
  document.getElementById('drawPrompt').textContent = gameState.currentPrompt;
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  setupDrawing(canvas, ctx);
}

function setupDrawing(canvas, ctx) {
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);
}

function startDrawing(e) {
  isDrawing = true;
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const ctx = e.target.getContext('2d');
  ctx.beginPath();
  ctx.moveTo(x, y);
}

function draw(e) {
  if (!isDrawing) return;
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const ctx = e.target.getContext('2d');
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  ctx.strokeStyle = currentColor;
  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
}

function stopDrawing() { isDrawing = false; }

function selectColor(color, e) {  // FIXED: Added event parameter
  currentColor = color;
  document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('active'));
  e.target.classList.add('active');
}

function clearCanvas() {
  const canvas = document.getElementById('drawCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function nextDrawRound() { switchPlayer(); initDrawGuess(); }

function initDiceRace() {
  gameState.player1Score = 0;
  gameState.player2Score = 0;
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  gameState.targetScore = 50;
  updateDiceScores();
}

function rollDice() {
  // Only allow moves if it's your turn and other player is connected
  if (!gameState.currentPlayer || gameState.currentPlayer !== myPlayerNumber || !otherPlayerConnected) return;
  
  const roll = Math.floor(Math.random() * 6) + 1;
  gameState.lastRoll = roll;
  const diceSymbols = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
  document.getElementById('diceDisplay').textContent = diceSymbols[roll - 1];
  if (gameState.currentPlayer === 1) gameState.player1Score += roll;  // FIXED
  else gameState.player2Score += roll;
  updateDiceScores();
  if (gameState.player1Score >= gameState.targetScore || gameState.player2Score >= gameState.targetScore) {
    const winner = gameState.player1Score >= gameState.targetScore ? 1 : 2;
    const winningScore = winner === 1 ? gameState.player1Score : gameState.player2Score;
    setTimeout(() => {
      syncGameResult(winner, `PLAYER ${winner} VICTORY WITH ${winningScore} POINTS!`, winningScore);
    }, 500);
  } else {
    switchPlayer();
  }
  syncGameState();
}

function updateDiceScores() {
  const player1Name = (document.getElementById('player1Name').value || 'ELENA').toUpperCase();
  const player2Name = (document.getElementById('player2Name').value || 'BRYAN').toUpperCase();
  document.getElementById('diceScores').innerHTML = `${player1Name}: ${gameState.player1Score} | ${player2Name}: ${gameState.player2Score}`;
}

function initSequence() {
  gameState.sequence = [];
  gameState.playerSequence = [];
  gameState.round = 1;
  gameState.showingSequence = false;
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  document.getElementById('sequenceScore').textContent = `ROUND: ${gameState.round}`;
  const grid = document.getElementById('sequenceGrid');
  grid.innerHTML = '';
  const colors = ['#ff0040', '#00ffff', '#00ff00', '#ffff00'];
  for (let i = 0; i < 4; i++) {
    const button = document.createElement('div');
    button.className = 'number-button';
    button.style.backgroundColor = colors[i];
    button.onclick = () => addToPlayerSequence(i);
    grid.appendChild(button);
  }
}

function startSequenceRound() {
  gameState.sequence.push(Math.floor(Math.random() * 4));
  gameState.playerSequence = [];
  gameState.showingSequence = true;
  showSequence();
}

function showSequence() {
  const colors = ['#ff0040', '#00ffff', '#00ff00', '#ffff00'];
  const display = document.getElementById('sequenceDisplay');
  display.innerHTML = '';
  gameState.sequence.forEach((colorIndex, index) => {
    setTimeout(() => {
      const item = document.createElement('div');
      item.style.cssText = `display: inline-block; width: 40px; height: 40px; margin: 5px; 
        background: ${colors[colorIndex]}; border: 2px solid #00ff00; text-align: center; 
        line-height: 36px; font-weight: bold; color: #000;`;
      item.textContent = index + 1;
      display.appendChild(item);
      if (index === gameState.sequence.length - 1) {
        setTimeout(() => { gameState.showingSequence = false; }, 1000);
      }
    }, index * 600);
  });
}

function addToPlayerSequence(colorIndex) {
  if (gameState.showingSequence) return;
  gameState.playerSequence.push(colorIndex);
  if (gameState.playerSequence[gameState.playerSequence.length - 1] !== gameState.sequence[gameState.playerSequence.length - 1]) {
    syncGameResult(currentPlayer, `SEQUENCE ERROR! PLAYER ${currentPlayer} SCORED ${gameState.round - 1} POINTS!`, gameState.round - 1);
    return;
  }
  if (gameState.playerSequence.length === gameState.sequence.length) {
    gameState.round++;
    document.getElementById('sequenceScore').textContent = `ROUND: ${gameState.round}`;
    if (gameState.round > 10) {
      syncGameResult(currentPlayer, `MAXIMUM ROUNDS COMPLETED! PLAYER ${currentPlayer} ACHIEVED PERFECT SCORE!`, 10);
    } else {
      setTimeout(() => startSequenceRound(), 1000);
    }
  }
}

function initWordChain() {
  gameState.wordChain = [];
  gameState.usedWords = new Set();
  gameState.currentPlayer = 1;
  currentPlayer = 1; 
  syncGameState();
  document.getElementById('chainDisplay').textContent = 'START WITH ANY WORD';
  document.getElementById('chainInput').value = '';
  document.getElementById('chainResult').innerHTML = '';
}

function submitChainWord() {
  // Only allow moves if it's your turn and other player is connected
  if (!gameState.currentPlayer || gameState.currentPlayer !== myPlayerNumber || !otherPlayerConnected) return;
  
  const word = document.getElementById('chainInput').value.toUpperCase().trim();
  if (word.length < 2) {
    alert('MINIMUM 2 LETTERS REQUIRED');
    return;
  }
  if (gameState.usedWords.has(word)) {
    alert('WORD ALREADY USED');
    return;
  }
  if (gameState.wordChain.length > 0) {
    const lastWord = gameState.wordChain[gameState.wordChain.length - 1];
    if (word[0] !== lastWord.slice(-1)) {
      alert(`WORD MUST START WITH "${lastWord.slice(-1)}"`);
      return;
    }
  }
  gameState.wordChain.push(word);
  gameState.usedWords.add(word);
  document.getElementById('chainDisplay').innerHTML = `<strong>CHAIN:</strong> ${gameState.wordChain.join(' → ')}`;
  document.getElementById('chainInput').value = '';
  const nextLetter = word.slice(-1);
  document.getElementById('chainResult').innerHTML = `<p>ACCEPTED! NEXT WORD MUST START WITH "${nextLetter}"</p>`;
  switchPlayer();
  syncGameState();
   
}

function initQuickDraw() {
  const prompts = ['STAR', 'HEART', 'CIRCLE', 'SQUARE', 'TRIANGLE', 'FACE', 'ARROW', 'LIGHTNING'];
  gameState.currentPrompt = prompts[Math.floor(Math.random() * prompts.length)];
  gameState.timeLeft = 30;
  gameState.drawing = false;
  currentPlayer = 1; 
  syncGameState();
  document.getElementById('quickDrawPrompt').textContent = gameState.currentPrompt;
  document.getElementById('quickDrawTimer').textContent = gameState.timeLeft;
  const canvas = document.getElementById('quickDrawCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  setupQuickDrawing(canvas, ctx);
}

function setupQuickDrawing(canvas, ctx) {
  canvas.addEventListener('mousedown', startQuickDrawing);
  canvas.addEventListener('mousemove', quickDraw);
  canvas.addEventListener('mouseup', stopQuickDrawing);
  canvas.addEventListener('mouseout', stopQuickDrawing);
}

function startQuickDrawing(e) {
  if (!gameState.drawing) return;
  isDrawing = true;
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const ctx = e.target.getContext('2d');
  ctx.beginPath();
  ctx.moveTo(x, y);
}

function quickDraw(e) {
  if (!isDrawing || !gameState.drawing) return;
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const ctx = e.target.getContext('2d');
  ctx.lineWidth = 4;
  ctx.lineCap = 'round';
  ctx.strokeStyle = '#00ff00';
  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);
}

function stopQuickDrawing() {
  isDrawing = false;
}

function startQuickDraw() {
  gameState.drawing = true;
  gameState.timeLeft = 30;
  const timer = setInterval(() => {
    gameState.timeLeft--;
    document.getElementById('quickDrawTimer').textContent = gameState.timeLeft;
    if (gameState.timeLeft <= 0) {
      clearInterval(timer);
      gameState.drawing = false;
      alert(`TIME EXPIRED! PLAYER ${currentPlayer} COMPLETED DRAWING "${gameState.currentPrompt}"`);
    }
  }, 1000);
}

function nextQuickDraw() {
  switchPlayer();
  initQuickDraw();
}

// Messages functionality
function sendMessage() {
  const input = document.getElementById('messageInput');
  const messageText = input.value.trim();
  if (!messageText) return;
  
  const player1Name = (document.getElementById('player1Name').value || 'ELENA').toUpperCase();
  const player2Name = (document.getElementById('player2Name').value || 'BRYAN').toUpperCase();
  const currentPlayerName = myPlayerNumber === 1 ? player1Name : player2Name;
  
  const message = {
    sender: currentPlayerName,
    senderNumber: myPlayerNumber,
    text: messageText.toUpperCase(),
    timestamp: Date.now(),
    displayTime: new Date().toLocaleTimeString()
  };
  
  // Add to Firebase instead of local array
  database.ref('gameSession/messages').push(message).then(() => {
    console.log('Message sent successfully');
    input.value = '';
  }).catch((error) => {
    console.error('Error sending message:', error);
    // Fallback to local storage if Firebase fails
    gameMessages.push(message);
    input.value = '';
    displayMessages();
    saveData();
  });
}

function displayMessages() {
  const container = document.getElementById('messagesContainer');
  if (gameMessages.length === 0) {
    container.innerHTML = '<div style="text-align: center; color: #666; font-style: italic;">AWAITING TRANSMISSION...</div>';
    return;
  }
  
  // Sort messages by timestamp to ensure correct order
  const sortedMessages = [...gameMessages].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
  
  container.innerHTML = sortedMessages.map(message => `
    <div class="message">
      <div class="message-sender">${message.sender} • ${message.displayTime || message.timestamp}</div>
      <div class="message-text">${message.text}</div>
    </div>
  `).join('');
  container.scrollTop = container.scrollHeight;
}

function clearMessages() {
  // Clear Firebase messages
  database.ref('gameSession/messages').remove().then(() => {
    console.log('Messages cleared from Firebase');
    gameMessages = [];
    displayMessages();
    saveData();
  }).catch((error) => {
    console.error('Error clearing messages:', error);
    // Fallback to local clear if Firebase fails
    gameMessages = [];
    displayMessages();
    saveData();
  });
}


// Event listeners - SINGLE DEFINITION
document.addEventListener('DOMContentLoaded', function() {
  document.getElementById('passwordInput').addEventListener('keypress', e => {
    if(e.key==='Enter') checkPassword();
  });
  document.getElementById('loginButton').addEventListener('click', checkPassword);
  document.getElementById('player1Name').addEventListener('input', () => {
    updatePlayerNames();
    saveData(); // ADD THIS
  });
  document.getElementById('player2Name').addEventListener('input', () => {
    updatePlayerNames();
    saveData(); // ADD THIS
  });
  loadData();
  loadProfilePictures();
  updateGlobalScores();
  updatePlayerNames();
});

// General key press handlers for game inputs - SINGLE DEFINITION
document.addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    if (currentGame === 'anagrams' && document.getElementById('anagramInput') === document.activeElement) submitAnagram();
    else if (currentGame === 'mathrace' && document.getElementById('mathInput') === document.activeElement) submitMath();
    else if (currentGame === 'wordchain' && document.getElementById('chainInput') === document.activeElement) submitChainWord();
    else if (document.getElementById('messageInput') === document.activeElement) sendMessage();
  }
});

<!-- Secret reset button (invisible) -->
<button class="secret-reset" id="secretReset" onclick="handleSecretClick()"></button>
  
</script>
</body>
</html>
